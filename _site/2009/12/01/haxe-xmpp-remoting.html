<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="content-language" content="en" />
<meta name="description" content="Panzerkunst">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<meta name="author" content="disktree.net">
<meta name="publisher" content="disktree.net">
<title>HaXe/XMPP remoting</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/css/disktree.css">
<script type="text/javascript" src="/js/jquery.js"></script>
</head>
<body>
<div id="header">
	<a href="/">DISKTREE.NET // PANZERKUNST</a>
	<a href="http://jabber.spektral.at/roar/">ROAR</a>
	<a class="rss" href="/atom.xml">SYNDICATE</a>
</div>
<div id="content"><div class="post">
<p>I have added a (async) haXe remoting remix to the HXMPP library using XMPP as transport, and created following example to test it:
[ HXR flash example ]</p>

<p>The app:
* embeds the same SWF twice in a HTML site
* the SWF logs into the jabber server with passed account information using SASL-MD5 authentication (password is hidden)
* creates an instance of the application
* create a haXe remoting host in context of the instance to listen for incoming calls.
* create a haXe remoting proxy in context of the instance for outgoing calls.
* on button click:
<strong> creates random values for the next circle to add to the other entities canvas
</strong> adds a circle to the remote entities canvas by calling a function on the proxy</p>

<p>A great benefit of HXR (haXe-remoting) over XMPP is that EVERY entitiy/target, also clients, can act as remote host. Which means i can call methods on a client from any other entity (a server or another client). Pretty cool for round based games and stuff.</p>

<p>Important thing missing is a access model for the remote host.
Currently every entity is allowed to call methods.
(Workaround would be be to add a IQ/HXR filter to block remaing packet collectors)</p>

</div>
</div>
</body>
</html>